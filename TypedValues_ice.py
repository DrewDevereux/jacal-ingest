# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.7.0
#
# <auto-generated>
#
# Generated from file `TypedValues.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module icedefs.askap
_M_icedefs = Ice.openModule('icedefs')
_M_icedefs.askap = Ice.openModule('icedefs.askap')
__name__ = 'icedefs.askap'

# Start of module icedefs.askap.interfaces
_M_icedefs.askap.interfaces = Ice.openModule('icedefs.askap.interfaces')
__name__ = 'icedefs.askap.interfaces'

if 'AskapIceException' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.AskapIceException = Ice.createTempClass()
    class AskapIceException(Ice.UserException):
        """
        Base exception from which all ICE exceptions thrown by
        ASKAPsoft code should derive from. The reason string shall be
        used to indicate why the exception was thrown
        """
        def __init__(self, reason=''):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::askap::interfaces::AskapIceException'

    _M_icedefs.askap.interfaces._t_AskapIceException = IcePy.defineException('::askap::interfaces::AskapIceException', AskapIceException, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    AskapIceException._ice_type = _M_icedefs.askap.interfaces._t_AskapIceException

    _M_icedefs.askap.interfaces.AskapIceException = AskapIceException
    del AskapIceException

if '_t_ParameterMap' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_ParameterMap = IcePy.defineDictionary('::askap::interfaces::ParameterMap', (), IcePy._t_string, IcePy._t_string)

if '_t_BoolSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_BoolSeq = IcePy.defineSequence('::askap::interfaces::BoolSeq', (), IcePy._t_bool)

if '_t_ByteSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_ByteSeq = IcePy.defineSequence('::askap::interfaces::ByteSeq', (), IcePy._t_byte)

if '_t_ShortSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_ShortSeq = IcePy.defineSequence('::askap::interfaces::ShortSeq', (), IcePy._t_short)

if '_t_IntSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_IntSeq = IcePy.defineSequence('::askap::interfaces::IntSeq', (), IcePy._t_int)

if '_t_LongSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_LongSeq = IcePy.defineSequence('::askap::interfaces::LongSeq', (), IcePy._t_long)

if '_t_FloatSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_FloatSeq = IcePy.defineSequence('::askap::interfaces::FloatSeq', (), IcePy._t_float)

if '_t_DoubleSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_DoubleSeq = IcePy.defineSequence('::askap::interfaces::DoubleSeq', (), IcePy._t_double)

if '_t_StringSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_StringSeq = IcePy.defineSequence('::askap::interfaces::StringSeq', (), IcePy._t_string)

if 'FloatComplex' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.FloatComplex = Ice.createTempClass()
    class FloatComplex(object):
        """
        A single-precision complex number.
        """
        def __init__(self, real=0.0, imag=0.0):
            self.real = real
            self.imag = imag

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_icedefs.askap.interfaces.FloatComplex):
                return NotImplemented
            else:
                if self.real != other.real:
                    return False
                if self.imag != other.imag:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_FloatComplex)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_FloatComplex = IcePy.defineStruct('::askap::interfaces::FloatComplex', FloatComplex, (), (
        ('real', (), IcePy._t_float),
        ('imag', (), IcePy._t_float)
    ))

    _M_icedefs.askap.interfaces.FloatComplex = FloatComplex
    del FloatComplex

if '_t_FloatComplexSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_FloatComplexSeq = IcePy.defineSequence('::askap::interfaces::FloatComplexSeq', (), _M_icedefs.askap.interfaces._t_FloatComplex)

if 'DoubleComplex' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.DoubleComplex = Ice.createTempClass()
    class DoubleComplex(object):
        """
        A double-precision complex number.
        """
        def __init__(self, real=0.0, imag=0.0):
            self.real = real
            self.imag = imag

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_icedefs.askap.interfaces.DoubleComplex):
                return NotImplemented
            else:
                if self.real != other.real:
                    return False
                if self.imag != other.imag:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_DoubleComplex)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_DoubleComplex = IcePy.defineStruct('::askap::interfaces::DoubleComplex', DoubleComplex, (), (
        ('real', (), IcePy._t_double),
        ('imag', (), IcePy._t_double)
    ))

    _M_icedefs.askap.interfaces.DoubleComplex = DoubleComplex
    del DoubleComplex

if '_t_DoubleComplexSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_DoubleComplexSeq = IcePy.defineSequence('::askap::interfaces::DoubleComplexSeq', (), _M_icedefs.askap.interfaces._t_DoubleComplex)

if 'CoordSys' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.CoordSys = Ice.createTempClass()
    class CoordSys(Ice.EnumBase):
        """
        Coordinate frame type
        """

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    CoordSys.J2000 = CoordSys("J2000", 0)
    CoordSys.AZEL = CoordSys("AZEL", 1)
    CoordSys._enumerators = { 0:CoordSys.J2000, 1:CoordSys.AZEL }

    _M_icedefs.askap.interfaces._t_CoordSys = IcePy.defineEnum('::askap::interfaces::CoordSys', CoordSys, (), CoordSys._enumerators)

    _M_icedefs.askap.interfaces.CoordSys = CoordSys
    del CoordSys

if 'Direction' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.Direction = Ice.createTempClass()
    class Direction(object):
        """
        Astronomical direction (e.g. a casacore measure)
        Members:
        coord1 -- RA/azimuth (in degrees)
        coord2 -- Dec/elevation (in degrees)
        sys -- coordinate frame
        """
        def __init__(self, coord1=0.0, coord2=0.0, sys=_M_icedefs.askap.interfaces.CoordSys.J2000):
            self.coord1 = coord1
            self.coord2 = coord2
            self.sys = sys

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_icedefs.askap.interfaces.Direction):
                return NotImplemented
            else:
                if self.coord1 != other.coord1:
                    return False
                if self.coord2 != other.coord2:
                    return False
                if self.sys != other.sys:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_Direction)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_Direction = IcePy.defineStruct('::askap::interfaces::Direction', Direction, (), (
        ('coord1', (), IcePy._t_double),
        ('coord2', (), IcePy._t_double),
        ('sys', (), _M_icedefs.askap.interfaces._t_CoordSys)
    ))

    _M_icedefs.askap.interfaces.Direction = Direction
    del Direction

if '_t_DirectionSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_DirectionSeq = IcePy.defineSequence('::askap::interfaces::DirectionSeq', (), _M_icedefs.askap.interfaces._t_Direction)

# End of module icedefs.askap.interfaces

__name__ = 'icedefs.askap'

# End of module icedefs.askap

# Start of module icedefs.askap
__name__ = 'icedefs.askap'

# Start of module icedefs.askap.interfaces
__name__ = 'icedefs.askap.interfaces'

if 'TypedValueType' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueType = Ice.createTempClass()
    class TypedValueType(Ice.EnumBase):
        """
        Enum to represent data types.
        """

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    TypedValueType.TypeNull = TypedValueType("TypeNull", 0)
    TypedValueType.TypeFloat = TypedValueType("TypeFloat", 1)
    TypedValueType.TypeDouble = TypedValueType("TypeDouble", 2)
    TypedValueType.TypeInt = TypedValueType("TypeInt", 3)
    TypedValueType.TypeLong = TypedValueType("TypeLong", 4)
    TypedValueType.TypeString = TypedValueType("TypeString", 5)
    TypedValueType.TypeBool = TypedValueType("TypeBool", 6)
    TypedValueType.TypeFloatComplex = TypedValueType("TypeFloatComplex", 7)
    TypedValueType.TypeDoubleComplex = TypedValueType("TypeDoubleComplex", 8)
    TypedValueType.TypeFloatSeq = TypedValueType("TypeFloatSeq", 9)
    TypedValueType.TypeDoubleSeq = TypedValueType("TypeDoubleSeq", 10)
    TypedValueType.TypeIntSeq = TypedValueType("TypeIntSeq", 11)
    TypedValueType.TypeLongSeq = TypedValueType("TypeLongSeq", 12)
    TypedValueType.TypeStringSeq = TypedValueType("TypeStringSeq", 13)
    TypedValueType.TypeBoolSeq = TypedValueType("TypeBoolSeq", 14)
    TypedValueType.TypeFloatComplexSeq = TypedValueType("TypeFloatComplexSeq", 15)
    TypedValueType.TypeDoubleComplexSeq = TypedValueType("TypeDoubleComplexSeq", 16)
    TypedValueType.TypeDirection = TypedValueType("TypeDirection", 17)
    TypedValueType.TypeDirectionSeq = TypedValueType("TypeDirectionSeq", 18)
    TypedValueType._enumerators = { 0:TypedValueType.TypeNull, 1:TypedValueType.TypeFloat, 2:TypedValueType.TypeDouble, 3:TypedValueType.TypeInt, 4:TypedValueType.TypeLong, 5:TypedValueType.TypeString, 6:TypedValueType.TypeBool, 7:TypedValueType.TypeFloatComplex, 8:TypedValueType.TypeDoubleComplex, 9:TypedValueType.TypeFloatSeq, 10:TypedValueType.TypeDoubleSeq, 11:TypedValueType.TypeIntSeq, 12:TypedValueType.TypeLongSeq, 13:TypedValueType.TypeStringSeq, 14:TypedValueType.TypeBoolSeq, 15:TypedValueType.TypeFloatComplexSeq, 16:TypedValueType.TypeDoubleComplexSeq, 17:TypedValueType.TypeDirection, 18:TypedValueType.TypeDirectionSeq }

    _M_icedefs.askap.interfaces._t_TypedValueType = IcePy.defineEnum('::askap::interfaces::TypedValueType', TypedValueType, (), TypedValueType._enumerators)

    _M_icedefs.askap.interfaces.TypedValueType = TypedValueType
    del TypedValueType

if 'TypedValue' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValue = Ice.createTempClass()
    class TypedValue(Ice.Value):
        """
        Base class for typed data types.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull):
            self.type = type

        def ice_id(self):
            return '::askap::interfaces::TypedValue'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValue'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValue)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValue = IcePy.defineValue('::askap::interfaces::TypedValue', TypedValue, -1, (), False, False, None, (('type', (), _M_icedefs.askap.interfaces._t_TypedValueType, False, 0),))
    TypedValue._ice_type = _M_icedefs.askap.interfaces._t_TypedValue

    _M_icedefs.askap.interfaces.TypedValue = TypedValue
    del TypedValue

if 'TypedValueFloat' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueFloat = Ice.createTempClass()
    class TypedValueFloat(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a float type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=0.0):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueFloat'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueFloat'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueFloat)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueFloat = IcePy.defineValue('::askap::interfaces::TypedValueFloat', TypedValueFloat, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_float, False, 0),))
    TypedValueFloat._ice_type = _M_icedefs.askap.interfaces._t_TypedValueFloat

    _M_icedefs.askap.interfaces.TypedValueFloat = TypedValueFloat
    del TypedValueFloat

if 'TypedValueDouble' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDouble = Ice.createTempClass()
    class TypedValueDouble(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a double precision float type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=0.0):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDouble'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDouble'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDouble)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDouble = IcePy.defineValue('::askap::interfaces::TypedValueDouble', TypedValueDouble, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_double, False, 0),))
    TypedValueDouble._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDouble

    _M_icedefs.askap.interfaces.TypedValueDouble = TypedValueDouble
    del TypedValueDouble

if 'TypedValueInt' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueInt = Ice.createTempClass()
    class TypedValueInt(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for an integer type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=0):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueInt'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueInt'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueInt)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueInt = IcePy.defineValue('::askap::interfaces::TypedValueInt', TypedValueInt, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_int, False, 0),))
    TypedValueInt._ice_type = _M_icedefs.askap.interfaces._t_TypedValueInt

    _M_icedefs.askap.interfaces.TypedValueInt = TypedValueInt
    del TypedValueInt

if 'TypedValueLong' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueLong = Ice.createTempClass()
    class TypedValueLong(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a long integer type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=0):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueLong'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueLong'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueLong)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueLong = IcePy.defineValue('::askap::interfaces::TypedValueLong', TypedValueLong, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_long, False, 0),))
    TypedValueLong._ice_type = _M_icedefs.askap.interfaces._t_TypedValueLong

    _M_icedefs.askap.interfaces.TypedValueLong = TypedValueLong
    del TypedValueLong

if 'TypedValueString' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueString = Ice.createTempClass()
    class TypedValueString(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a string type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=''):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueString'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueString'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueString)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueString = IcePy.defineValue('::askap::interfaces::TypedValueString', TypedValueString, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_string, False, 0),))
    TypedValueString._ice_type = _M_icedefs.askap.interfaces._t_TypedValueString

    _M_icedefs.askap.interfaces.TypedValueString = TypedValueString
    del TypedValueString

if 'TypedValueBool' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueBool = Ice.createTempClass()
    class TypedValueBool(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a boolean type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=False):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueBool'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueBool'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueBool)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueBool = IcePy.defineValue('::askap::interfaces::TypedValueBool', TypedValueBool, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), IcePy._t_bool, False, 0),))
    TypedValueBool._ice_type = _M_icedefs.askap.interfaces._t_TypedValueBool

    _M_icedefs.askap.interfaces.TypedValueBool = TypedValueBool
    del TypedValueBool

if 'TypedValueFloatComplex' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueFloatComplex = Ice.createTempClass()
    class TypedValueFloatComplex(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a single precision floating point complex number.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=Ice._struct_marker):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            if value is Ice._struct_marker:
                self.value = _M_icedefs.askap.interfaces.FloatComplex()
            else:
                self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueFloatComplex'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueFloatComplex'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueFloatComplex)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueFloatComplex = IcePy.defineValue('::askap::interfaces::TypedValueFloatComplex', TypedValueFloatComplex, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_FloatComplex, False, 0),))
    TypedValueFloatComplex._ice_type = _M_icedefs.askap.interfaces._t_TypedValueFloatComplex

    _M_icedefs.askap.interfaces.TypedValueFloatComplex = TypedValueFloatComplex
    del TypedValueFloatComplex

if 'TypedValueDoubleComplex' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDoubleComplex = Ice.createTempClass()
    class TypedValueDoubleComplex(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a double precision floating point complex number.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=Ice._struct_marker):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            if value is Ice._struct_marker:
                self.value = _M_icedefs.askap.interfaces.DoubleComplex()
            else:
                self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDoubleComplex'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDoubleComplex'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDoubleComplex)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDoubleComplex = IcePy.defineValue('::askap::interfaces::TypedValueDoubleComplex', TypedValueDoubleComplex, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_DoubleComplex, False, 0),))
    TypedValueDoubleComplex._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDoubleComplex

    _M_icedefs.askap.interfaces.TypedValueDoubleComplex = TypedValueDoubleComplex
    del TypedValueDoubleComplex

if 'TypedValueDirection' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDirection = Ice.createTempClass()
    class TypedValueDirection(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for astronomical direction
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=Ice._struct_marker):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            if value is Ice._struct_marker:
                self.value = _M_icedefs.askap.interfaces.Direction()
            else:
                self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDirection'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDirection'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDirection)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDirection = IcePy.defineValue('::askap::interfaces::TypedValueDirection', TypedValueDirection, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_Direction, False, 0),))
    TypedValueDirection._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDirection

    _M_icedefs.askap.interfaces.TypedValueDirection = TypedValueDirection
    del TypedValueDirection

if 'TypedValueFloatSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueFloatSeq = Ice.createTempClass()
    class TypedValueFloatSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of floats type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueFloatSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueFloatSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueFloatSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueFloatSeq = IcePy.defineValue('::askap::interfaces::TypedValueFloatSeq', TypedValueFloatSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_FloatSeq, False, 0),))
    TypedValueFloatSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueFloatSeq

    _M_icedefs.askap.interfaces.TypedValueFloatSeq = TypedValueFloatSeq
    del TypedValueFloatSeq

if 'TypedValueDoubleSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDoubleSeq = Ice.createTempClass()
    class TypedValueDoubleSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of doubles type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDoubleSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDoubleSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDoubleSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDoubleSeq = IcePy.defineValue('::askap::interfaces::TypedValueDoubleSeq', TypedValueDoubleSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_DoubleSeq, False, 0),))
    TypedValueDoubleSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDoubleSeq

    _M_icedefs.askap.interfaces.TypedValueDoubleSeq = TypedValueDoubleSeq
    del TypedValueDoubleSeq

if 'TypedValueIntSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueIntSeq = Ice.createTempClass()
    class TypedValueIntSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of integers type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueIntSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueIntSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueIntSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueIntSeq = IcePy.defineValue('::askap::interfaces::TypedValueIntSeq', TypedValueIntSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_IntSeq, False, 0),))
    TypedValueIntSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueIntSeq

    _M_icedefs.askap.interfaces.TypedValueIntSeq = TypedValueIntSeq
    del TypedValueIntSeq

if 'TypedValueLongSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueLongSeq = Ice.createTempClass()
    class TypedValueLongSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of long integers type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueLongSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueLongSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueLongSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueLongSeq = IcePy.defineValue('::askap::interfaces::TypedValueLongSeq', TypedValueLongSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_LongSeq, False, 0),))
    TypedValueLongSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueLongSeq

    _M_icedefs.askap.interfaces.TypedValueLongSeq = TypedValueLongSeq
    del TypedValueLongSeq

if 'TypedValueStringSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueStringSeq = Ice.createTempClass()
    class TypedValueStringSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of strings type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueStringSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueStringSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueStringSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueStringSeq = IcePy.defineValue('::askap::interfaces::TypedValueStringSeq', TypedValueStringSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_StringSeq, False, 0),))
    TypedValueStringSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueStringSeq

    _M_icedefs.askap.interfaces.TypedValueStringSeq = TypedValueStringSeq
    del TypedValueStringSeq

if 'TypedValueBoolSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueBoolSeq = Ice.createTempClass()
    class TypedValueBoolSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of booleans type.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueBoolSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueBoolSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueBoolSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueBoolSeq = IcePy.defineValue('::askap::interfaces::TypedValueBoolSeq', TypedValueBoolSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_BoolSeq, False, 0),))
    TypedValueBoolSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueBoolSeq

    _M_icedefs.askap.interfaces.TypedValueBoolSeq = TypedValueBoolSeq
    del TypedValueBoolSeq

if 'TypedValueFloatComplexSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueFloatComplexSeq = Ice.createTempClass()
    class TypedValueFloatComplexSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of single precision floating point complex number.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueFloatComplexSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueFloatComplexSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueFloatComplexSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueFloatComplexSeq = IcePy.defineValue('::askap::interfaces::TypedValueFloatComplexSeq', TypedValueFloatComplexSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_FloatComplexSeq, False, 0),))
    TypedValueFloatComplexSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueFloatComplexSeq

    _M_icedefs.askap.interfaces.TypedValueFloatComplexSeq = TypedValueFloatComplexSeq
    del TypedValueFloatComplexSeq

if 'TypedValueDoubleComplexSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDoubleComplexSeq = Ice.createTempClass()
    class TypedValueDoubleComplexSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of double precision floating point complex number.
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDoubleComplexSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDoubleComplexSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDoubleComplexSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDoubleComplexSeq = IcePy.defineValue('::askap::interfaces::TypedValueDoubleComplexSeq', TypedValueDoubleComplexSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_DoubleComplexSeq, False, 0),))
    TypedValueDoubleComplexSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDoubleComplexSeq

    _M_icedefs.askap.interfaces.TypedValueDoubleComplexSeq = TypedValueDoubleComplexSeq
    del TypedValueDoubleComplexSeq

if 'TypedValueDirectionSeq' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TypedValueDirectionSeq = Ice.createTempClass()
    class TypedValueDirectionSeq(_M_icedefs.askap.interfaces.TypedValue):
        """
        Class for a sequence of direction typed
        """
        def __init__(self, type=_M_icedefs.askap.interfaces.TypedValueType.TypeNull, value=None):
            _M_icedefs.askap.interfaces.TypedValue.__init__(self, type)
            self.value = value

        def ice_id(self):
            return '::askap::interfaces::TypedValueDirectionSeq'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::TypedValueDirectionSeq'

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TypedValueDirectionSeq)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TypedValueDirectionSeq = IcePy.defineValue('::askap::interfaces::TypedValueDirectionSeq', TypedValueDirectionSeq, -1, (), False, False, _M_icedefs.askap.interfaces._t_TypedValue, (('value', (), _M_icedefs.askap.interfaces._t_DirectionSeq, False, 0),))
    TypedValueDirectionSeq._ice_type = _M_icedefs.askap.interfaces._t_TypedValueDirectionSeq

    _M_icedefs.askap.interfaces.TypedValueDirectionSeq = TypedValueDirectionSeq
    del TypedValueDirectionSeq

if '_t_TypedValueMap' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces._t_TypedValueMap = IcePy.defineDictionary('::askap::interfaces::TypedValueMap', (), IcePy._t_string, _M_icedefs.askap.interfaces._t_TypedValue)

if 'TimeTaggedTypedValueMap' not in _M_icedefs.askap.interfaces.__dict__:
    _M_icedefs.askap.interfaces.TimeTaggedTypedValueMap = Ice.createTempClass()
    class TimeTaggedTypedValueMap(object):
        """
        Time-tagged dictionary of typed data.
        Timestamp is a Binary Atomic Time representing microseconds since
        Modified Julian Date zero.
        """
        def __init__(self, timestamp=0, data=None):
            self.timestamp = timestamp
            self.data = data

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_icedefs.askap.interfaces.TimeTaggedTypedValueMap):
                return NotImplemented
            else:
                if self.timestamp != other.timestamp:
                    return False
                if self.data != other.data:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces._t_TimeTaggedTypedValueMap)

        __repr__ = __str__

    _M_icedefs.askap.interfaces._t_TimeTaggedTypedValueMap = IcePy.defineStruct('::askap::interfaces::TimeTaggedTypedValueMap', TimeTaggedTypedValueMap, (), (
        ('timestamp', (), IcePy._t_long),
        ('data', (), _M_icedefs.askap.interfaces._t_TypedValueMap)
    ))

    _M_icedefs.askap.interfaces.TimeTaggedTypedValueMap = TimeTaggedTypedValueMap
    del TimeTaggedTypedValueMap

# Start of module icedefs.askap.interfaces.datapublisher
_M_icedefs.askap.interfaces.datapublisher = Ice.openModule('icedefs.askap.interfaces.datapublisher')
__name__ = 'icedefs.askap.interfaces.datapublisher'

_M_icedefs.askap.interfaces.datapublisher._t_ITypedValueMapPublisher = IcePy.defineValue('::askap::interfaces::datapublisher::ITypedValueMapPublisher', Ice.Value, -1, (), False, True, None, ())

if 'ITypedValueMapPublisherPrx' not in _M_icedefs.askap.interfaces.datapublisher.__dict__:
    _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisherPrx = Ice.createTempClass()
    class ITypedValueMapPublisherPrx(Ice.ObjectPrx):

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        context -- The request context for the invocation.
        """
        def publish(self, values, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher._op_publish.invoke(self, ((values, ), context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def publishAsync(self, values, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher._op_publish.invokeAsync(self, ((values, ), context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_publish(self, values, _response=None, _ex=None, _sent=None, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher._op_publish.begin(self, ((values, ), _response, _ex, _sent, context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        """
        def end_publish(self, _r):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher._op_publish.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisherPrx.ice_checkedCast(proxy, '::askap::interfaces::datapublisher::ITypedValueMapPublisher', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisherPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::datapublisher::ITypedValueMapPublisher'
    _M_icedefs.askap.interfaces.datapublisher._t_ITypedValueMapPublisherPrx = IcePy.defineProxy('::askap::interfaces::datapublisher::ITypedValueMapPublisher', ITypedValueMapPublisherPrx)

    _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisherPrx = ITypedValueMapPublisherPrx
    del ITypedValueMapPublisherPrx

    _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher = Ice.createTempClass()
    class ITypedValueMapPublisher(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::askap::interfaces::datapublisher::ITypedValueMapPublisher')

        def ice_id(self, current=None):
            return '::askap::interfaces::datapublisher::ITypedValueMapPublisher'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::datapublisher::ITypedValueMapPublisher'

        def publish(self, values, current=None):
            """
            Publish a new map of named typed values.
            Arguments:
            values -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'publish' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces.datapublisher._t_ITypedValueMapPublisherDisp)

        __repr__ = __str__

    _M_icedefs.askap.interfaces.datapublisher._t_ITypedValueMapPublisherDisp = IcePy.defineClass('::askap::interfaces::datapublisher::ITypedValueMapPublisher', ITypedValueMapPublisher, (), None, ())
    ITypedValueMapPublisher._ice_type = _M_icedefs.askap.interfaces.datapublisher._t_ITypedValueMapPublisherDisp

    ITypedValueMapPublisher._op_publish = IcePy.Operation('publish', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_icedefs.askap.interfaces._t_TypedValueMap, False, 0),), (), None, ())

    _M_icedefs.askap.interfaces.datapublisher.ITypedValueMapPublisher = ITypedValueMapPublisher
    del ITypedValueMapPublisher

_M_icedefs.askap.interfaces.datapublisher._t_ITimeTaggedTypedValueMapPublisher = IcePy.defineValue('::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher', Ice.Value, -1, (), False, True, None, ())

if 'ITimeTaggedTypedValueMapPublisherPrx' not in _M_icedefs.askap.interfaces.datapublisher.__dict__:
    _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisherPrx = Ice.createTempClass()
    class ITimeTaggedTypedValueMapPublisherPrx(Ice.ObjectPrx):

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        context -- The request context for the invocation.
        """
        def publish(self, values, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher._op_publish.invoke(self, ((values, ), context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def publishAsync(self, values, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher._op_publish.invokeAsync(self, ((values, ), context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_publish(self, values, _response=None, _ex=None, _sent=None, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher._op_publish.begin(self, ((values, ), _response, _ex, _sent, context))

        """
        Publish a new map of named typed values.
        Arguments:
        values -- 
        """
        def end_publish(self, _r):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher._op_publish.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisherPrx.ice_checkedCast(proxy, '::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisherPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher'
    _M_icedefs.askap.interfaces.datapublisher._t_ITimeTaggedTypedValueMapPublisherPrx = IcePy.defineProxy('::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher', ITimeTaggedTypedValueMapPublisherPrx)

    _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisherPrx = ITimeTaggedTypedValueMapPublisherPrx
    del ITimeTaggedTypedValueMapPublisherPrx

    _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher = Ice.createTempClass()
    class ITimeTaggedTypedValueMapPublisher(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher')

        def ice_id(self, current=None):
            return '::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher'

        @staticmethod
        def ice_staticId():
            return '::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher'

        def publish(self, values, current=None):
            """
            Publish a new map of named typed values.
            Arguments:
            values -- 
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'publish' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_icedefs.askap.interfaces.datapublisher._t_ITimeTaggedTypedValueMapPublisherDisp)

        __repr__ = __str__

    _M_icedefs.askap.interfaces.datapublisher._t_ITimeTaggedTypedValueMapPublisherDisp = IcePy.defineClass('::askap::interfaces::datapublisher::ITimeTaggedTypedValueMapPublisher', ITimeTaggedTypedValueMapPublisher, (), None, ())
    ITimeTaggedTypedValueMapPublisher._ice_type = _M_icedefs.askap.interfaces.datapublisher._t_ITimeTaggedTypedValueMapPublisherDisp

    ITimeTaggedTypedValueMapPublisher._op_publish = IcePy.Operation('publish', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_icedefs.askap.interfaces._t_TimeTaggedTypedValueMap, False, 0),), (), None, ())

    _M_icedefs.askap.interfaces.datapublisher.ITimeTaggedTypedValueMapPublisher = ITimeTaggedTypedValueMapPublisher
    del ITimeTaggedTypedValueMapPublisher

# End of module icedefs.askap.interfaces.datapublisher

__name__ = 'icedefs.askap.interfaces'

# End of module icedefs.askap.interfaces

__name__ = 'icedefs.askap'

# End of module icedefs.askap
